Tutorial
========

The purpose of this tutorial is to introduce the nexxT framework from different perspectives. The most basic is the perspective of a user who wants to be able to use predefined configurations. Then we show the perspective of an integrator who creates and manipulates configurations of filter graphs using nexxT. The last perspective is the developer view who develops filters ready
to be integrated into the framework accessing both the python and the C++ API.

User Perspective
----------------

After installing nexxT as described in :ref:`autogenerated/introduction:Installation`, the command :ref:`commandline:nexxT-gui` is available in the virtual environment. Starting it with

.. code-block:: console

    $ nexxT-gui

brings up the nexxT graphical user interface:

.. image:: nexxT-gui.png

nexxT Nomenclature
++++++++++++++++++

A nexxT *configuration* provides one or more *applications*. *Applications* consist of a directed graph where the nodes are *filter* instances. *Filter* instances have input and output *ports*. Edges from output to input *ports* represent data flow *connections*. The *filters* can provide *properties* which can be manipulated in the GUI. For a clearer view it is possible to group subgraphs in so-called *composite filters*.

GUI walkthrough
+++++++++++++++

The GUI consists of a main window with a menu, a toolbar and several dock windows. We are going to walk through the provided functionality briefly:

- The **Configuration** dock window and the Configuration menu are the main places where the user interacts with the configuration. It is possible to load and save configuration files, start and stop applications, modify property values and also manipulate the underlying filter graph.
- The **Playback Control** dock window and the Playback menu are the places where the user browses and activates files for playback. The window is enabled only if an application with a playback filter is active. It also provides the familiar control elements for navigating through a data file.
- The **Recording Control** dock window and the Recording menu provide control over recording of data. The window is enabled only if an application with a recording filter is active.
- The **Log** window contains messages from both nexxT itself and the loaded plugins. It can be configured through the Log menu.
- The **Load** window shows the workload of the threads used in the application (only when applications are active).
- The **Profiling** window shows detailed filter timings if enabled through the Profiling menu.

Example configuration
+++++++++++++++++++++

The example configuration is installed in site-packages/nexxT/examples/framework/example.json. This file contains two applications *live* and *sim* and a composite filter *visualization*. You can inspect the filter graphs by right-clicking the item in the configuration view and selecting *Edit Graph*:

.. image:: example-graphs.png

The *live* application contains a camera grabber, an image processing filter, an HDF5 recorder and the visualization. The different colors in the graph are related to the different threads the filters run in. This application is ment to be executed live with a real camera. The CameraGrabber uses the first USB camera found on the system with default settings.

The *sim* application contains two readers for different flavours of input files (HDF5 or standard avi or mp4 containers), also the image processing filter and the visualization. This application is ment to be executed offline with data from disk. This allows to experiment with parameters and other algorithms.

The image processing step is ment just as an example of a computationally expensive operation. The blurring is implemented in a non-optimal way for demonstration purposes and minimal dependencies.

Executing the live application
++++++++++++++++++++++++++++++

Right-clicking 

    .. image:: example-app-context-menu.png

on one of the applications shows different options for activating the application:

.. list-table:: Application Context Menu
    :widths: 30 70
    :header-rows: 1

    * - Context menu entry
      - Effect
    * - Select application       
      - Application is selected but left uninitialized
    * - Init application
      - Application is initialized. A Playback file is not yet selected.
    * - Init and load sequence
      - Application is initialized and the selected playback file is loaded. Playback is not yet started (only relevant for playback apps)
    * - Init, load and play
      - Application is initialized and the selected playback file is loaded. Playback is started (only relevant for playback apps)

Execute *Init application* of the live configuration. If a camera is connected to your computer, you should see two images, the original image as delivered from the camera and the processed, blurred image from the image processing filter.

.. image:: example-live.png
    
The load monitor shows the load of the individual threads. In this example, the load introduced by the image processing is significant - the blue line is nearly always 100 %. This means that the image processing filter is probably slowing down the processing of the graph.

You might also see some warnings in the log monitor. They come from the QMultimedia package which is used to grab the images. Note that this choice has been made for demonstration purposes only with minimal dependencies. In a productivity environment, the capturing filter might be replaced with a wrapper around a better suited library (e.g., opencv).

You are now able to take a recording using the buttons of the Recording Control toolbar.

You can also change properties in the configuration view. In the example above, the scale property of the visualization filters has been changed to better fit to the screen dimensions. Note that there are settings with an immediate effect (e.g., scale) while other settings need a re-initialization of the application before taking effect (e.g., caption). It's up to the filter developer to decide about the effect of changed properties.

Executing the sim application
+++++++++++++++++++++++++++++

Clicking on the deinitialize 

    .. image:: example-deinitialize.png
    
button on the toolbar sets the gui into the uninitialized state. You can now start the *sim* application to replay the recording you have just made. Therefore, right-click on the sim application and execute *Init application*. The *Playback Control* window is activated now and you can navigate to the .h5 file recording. When the file is activated in the browser, the *Play* button is enabled. Click it to play back from the recording.

.. image:: example-sim.png

In principle it shall be possible to also play .mp4 files with this application. Due to the limitations of the QMultimedia package the supported file types are limited. 

Integrator Perspective
----------------------

The integrator's perspective on the nexxT framework is to maintain and modify existing or create new configurations with existing filter plugins. The main tool for achieving these tasks is the *Graph Editor* (see :ref:`tutorial:Example configuration`). In the next paragraphs, we show how to create a new configuration:

Click on the *New config* button in the toolbar and choose an appropriate location. Right-click the *apps* entry in the **Configuration** dock window and choose *Add application*:

    .. image:: example-add-application.png
    
You can change the name of the new application by pressing F2 in the configuration view. Start the graph editor of this application. The graph will be empty, and we are going to populate it. Right-clicking on an empty space in the graph editor brings up this pop-up menu:

    .. image:: example-graph-editor-context-menu.png
    
As you can see, there are multiple options to add filters:

.. list-table:: Graph Editor Context Menu
    :widths: 23 40 33
    :header-rows: 1

    * - Context menu entry
      - Effect
      - Discussion
    * - Add filter from file
      - You can choose a python file or a shared object / DLL. This file will be scanned for Filter classes and a list of available filters will be presented. In case a python file is created, this file is imported as a python module.
      - While this method is pretty easy and straight-forward, importing python code like this doesn't scale up. It is recommended that filters are imported by one of the two other ways. As of today, nexxT uses an absolute path to the file. After saving a config, it might be necessary to change these paths in the JSON file to be relative to the configuration file.
    * - Add filter from python module
      - You can choose a python module from the current python environment (dot notation can be used for packages).
      - This is preferrable over the file method if your filter is packaged in a standard python package which is installed via pip or similar tools. However, integrators have to remember the python module names of their filters.
    * - Filter Library
      - Filters which are registered with the 'nexxT.filters' entry point (see :py:class:`nexxT.interface.Filters.FilterSurrogate` for more information) are listed here in a tree structure. This is possible for filters defined in both domains, python and C++.
      - Most convenient approach for integrators. The method requires that the filter is installed with the correct entry_point definition in setup.py or setup.cfg.

Let's add a HDF5 reader to the application, using the filter library (*Filter Library* -> *harddisk* -> *HDF5Reader*). You will be presented with an empty filter:

    .. image:: example-hdf5-reader-empty.png

The HDF5 reader uses the concept of **dynamic ports** for being able to support arbitrary streams. These dynamic ports are defined by the integrator. There are context menus for filters and also for ports where dynamic ports can be added, removed and renamed. Each stream in the HDF5 file is then mapped to a dynamic output port with the name of the stream. The HDF5 reader can suggest port names from a template HDF5 file. Therefore, click on *Suggest dynamic ports ...* and choose the HDF5 file which was recorded in :ref:`tutorial:Executing the live application`.  You are presented with this suggestion:

    .. image:: example-suggest-ports.png
    
After acceptance, the video port is added to the filter. Another way to achieve the same effect is to use the filter's context menu and add a new dynamic output port with name video.

New filters are running in the main thread by default (indicated by the color green). The HDF5 reader is designed to run in a seperate thread instead (it will emit a warning in the logs if it runs in the main thread), so we can assign a new thread *reader* to it using the filter's context menu. Afterwards the color changes.

We can also see that the new filter is now part of the configuration tree view. The filter does not define any properties.

Next, we will add the visualization node for the video stream to the graph editor (*Filter Library* -> *examples* -> *framework* -> *ImageView*). The green color indicates that this filter is running in the main thread, and this setting should not be changed for visualization filters, because of QT requirements. This filter defines some properties which can be changed in the configuration view, namely *scale* and *caption*.

We can now connect the reader's output port with the visualization's input port by dragging a connection between the two:

    .. image:: example-reader-vis-connected.png
    
Now it's time to save the configuration in the tool bar and test it. Initialize the application with the context menu in the configuration view and choose the HDF5 file from the previous section. You should see the recorded data:

.. image:: example-first-app-running.png


Developer Perspectives
----------------------

One of the first things to decide when using nexxT is the data format to be used in the configuration files. There are a lot of possible choices, each with some pros and cons. A fundamental requirement on the data format is that the serialization and especially the deserialization operations shall be efficient. This is because the data is passed between filters in the serialized format and so these operations are heavily used while running a filter graph. The following (incomplete) table gives some hints on how data can be represented:

.. list-table:: 
    :widths: 26 37 37
    :header-rows: 1
    
    * - Method
      - Pros
      - Cons
      
    * - pickle
      - * (De-)serialization is easily implemented in python with pickle.dumps and pickle.loads.
        * Self-contained
      - * Can be slow depending on the data
        * Unusable in the C++ world

    * - `flatbuffers <https://google.github.io/flatbuffers/>`_
      - * Efficient and cross platform (de-)serialization library
        * Self-contained
      - * Depends on 3rd party library

    * - ctypes
      - * The approach can be used in both domains, python and C++.
        * In python, it is easy to define C structures using the ctypes library
        * In C++, regular C structs can be used
        * (De-)serialization is efficient. Zero-copy reading is supported.
        * Deserialized data access is straight-forward and the same between python and C++.
      - * If the structures are subject to change over time, manual version management is required (i.e., old structure definitions have to be kept and a version number must be present)
        * Synchronization between C++ and python type definitions might be tedious.
        * Not self-contained (structure definitions need to be kept seperate from the data).
        
For this tutorial, we decided to use the ctypes approach. Here at ifm we are using a proprietery data format which is also heavily using ctypes in the python world but doesn't show the cons of the pure ctypes approach listed above.
        
Python
++++++

Data Format
^^^^^^^^^^^

The data format is defined in the module :py:mod:`nexxT.examples.framework.ImageData`. It consists of the ImageHeader definition and two methods for deserializing and serializing images.

    .. literalinclude:: ../../nexxT/examples/framework/ImageData.py
        :pyobject: ImageHeader
        
The image data format is very simple, first there is a data header with image meta information followed by the raw image data buffer. 

The deserialization operation converts the so-defined data into a numpy array, usually without copying the data. In nexxT, QByteArray instances are used to pass data around, so the input argument of the deserialization operation is a QByteArray instance.

    .. literalinclude:: ../../nexxT/examples/framework/ImageData.py
        :pyobject: byteArrayToNumpy
        
The key for the zero-copy operation is to use memoryview(...) and use the buffer protocol to access data.

Similar ideas are used in the serialization implementation where only one copy of the data is made before passing it to the framework. This copy is usually necessary to ensure data consistency accross different threads. 

    .. literalinclude:: ../../nexxT/examples/framework/ImageData.py
        :pyobject: numpyToByteArray

A first simple filter
^^^^^^^^^^^^^^^^^^^^^

Having the data format defined, we can go on and show how to write a simple filter. The :py:class:`nexxT.examples.framework.ImageBlur.ImageBlur` filter has one static input and one static output port. It applies a blurring operation with an adjustable filter size. 

    .. literalinclude:: ../../nexxT/examples/framework/ImageBlur.py
        :pyobject: ImageBlur

In the constructor, the ports are created and the kernelSize property is defined. The onPortDataChanged method is then called whenever new data arrives at the input port. 

Note that nexxT always takes care about using the filter's thread for callbacks like onPortDataChanged(...), unless explictely otherwise stated in the documentation. A manual synchronization for data consistency shall not be necessary in a filter. That was one major drawback of our previous framework and the source of hard-to-find deadlocks and segmentation faults.

NexxT manages the lifecycles of the filters using a state machine. The onPortDataChanged(...) callback is executed after filters have reached their *ACTIVE* state. NexxT also ensures that no data samples are lost during initialization of the application or because some filters are slow.

.. image:: nexxT-filterstates.svg

**Slow filters will slow down the whole filter graph**. This is a major difference to ROS and ROS2 where data samples are discarded by default in favour of real-time performance. However this makes it hard to get reproducable results when developing potentially slow algorithms with data from disk.

The constructor and the onInit(...) method of a filter are called often from the nexxT framework when manipulating the filter graph. For that reason, it is strongly recommended, that these methods are inexpensive. Expensive operations shall be delayed until onOpen(...) or onStart(...) is called.

You can see that the QByteArray instances are copied. These copies are efficient shallow copies because QByteArray is using a copy-on-write strategy.

Display filters
^^^^^^^^^^^^^^^

Display filters present visualizations of incoming data. They are normal nexxT filter instances. We will shortly walk through the :py:class:`nexxT.examples.framework.ImageView.ImageView` filter with a focus on how the filter is written (and not how the display is achieved):

    .. literalinclude:: ../../nexxT/examples/framework/ImageView.py
        :pyobject: ImageView.__init__
        
The constructor adds the static input port where the images arrive and it defines two properties for the window caption and the scale factor of the view. It also shows how to use a slot for getting notified about changed properties.

An important aspect is that the actual widget is not created in the constructor, but the creation is delayed until the onOpen(...) function as already discussed in the previous section :ref:`tutorial:A first simple filter`.

    .. literalinclude:: ../../nexxT/examples/framework/ImageView.py
        :pyobject: ImageView.onOpen

In the onOpen(...) function, the display widget is created and registered in the main window. Therefore, it queries nexxT's MainWindow service and registers the display with the subplot method of the main window. The caption of a mainwindow can optionally include a "[row, col]" definition to layout multiple views in a grid inside one MDI window.

    .. literalinclude:: ../../nexxT/examples/framework/ImageView.py
        :pyobject: ImageView.onClose
        
The onClose(...) method is the inverse of onOpen(...). It releases the widget from the main window and clears the reference to it.

C++
+++

**Why using C++ instead of python?** The answer is, as often, better performance. While you can argue that performance is not affected much if the filter only uses a wrapper around a library such as opencv, the `python GIL <https://wiki.python.org/moin/GlobalInterpreterLock>`_ is a factor which might limit performance in a multithreaded application like nexxT. In a nutshell it means, that whenever python code is executed, the interpreter has the GIL locked to prevent other threads from modifying interpreter states. C extensions like numpy, opencv or PySide2 unlock the GIL during long-duration calls.

Writing filters in C++ is very similar to writing them in python. You define a class which inherits from the :cpp:class:`nexxT::Filter` base class and overwrite the same methods as in python. One difference is the usage of nexxT services like the MainWindow service used in :ref:`tutorial:Display filters`. In C++, these services are of type QObject. Therefore, you need to use `QMetaObject::invokeMethod <https://doc.qt.io/qt-5/qmetaobject.html#invokeMethod>`_ for accessing the slots defined from the meta object.

The plugin library links against the nexxT runtime library which is provided in nexxT installation directory. It also links against a QT library used for development only. Note that during runtime, the QT library bundled with PySide2 will be used regardless of which QT library has been used to develop. To be on the safe side, you should use a matching major.minor version, the patch level should be non-relevant. For example, to compile a plugin for the PySide2 version 5.14.2.3, you can use QT 5.14.0. 

Note that - unlike pure QT - PySide2 is not providing any compatibility guarantees between minor or patch level releases. This means that it is not possible to use nexxT with a different PySide2 version as it was compiled against. Because plugin libraries are not exposed through the shiboken2 binding generator but through the QLibrary interface, this hard dependency to use the exact same QT version is relaxed for the nexxT plugins where the rules for standard QT compatibility are taking place.

Each plugin library can announce one or more filter classes which are then constructed from the nexxT framework.

Camera Grabber
^^^^^^^^^^^^^^

Again, we will shortly walk through the CameraGrabber class with a focus on how to write a nexxT filter and not how to grab images from a camera. We use the `QMultimedia framework <https://doc.qt.io/qt-5/qtmultimedia-index.html>`_ for that.

    .. literalinclude:: ../../nexxT/tests/src/CameraGrabber.hpp
        :language: c
        :caption:
        
The CameraGrabber filter is defined in this header file. Because it uses signals and slots we need the Q_OBJECT macro in the class. We also need to call the macro :c:macro:`NEXXT_PLUGIN_DECLARE_FILTER` for being able to announce this filter in the plugin library.

    .. literalinclude:: ../../nexxT/tests/src/CameraGrabber.cpp
        :language: c
        :start-after: LITERAL_INCLUDE_START_1
        :end-before: LITERAL_INCLUDE_END_1
        
The constructors and destructors are straight forward. Long-running operations are delayed until onOpen(...). The constructor passes the BaseFilterEnvironment instance through to the base class just as the python implementation did.

    .. literalinclude:: ../../nexxT/tests/src/CameraGrabber.cpp
        :language: c
        :start-after: LITERAL_INCLUDE_START_3
        :end-before: LITERAL_INCLUDE_END_3

The onOpen(...) method create the necessary classes from the QMultimedia framework and sets up signal and slot connections for receiving new images and error handling. Note that this ensures that the slots are called in the filter's thread. onStart(...) starts the capturing, onStop(...) and onClose(...) are the inverse functions. Logging can be performed by using the macros defined in :ref:`cplusplus:Logging`.

    .. literalinclude:: ../../nexxT/tests/src/CameraGrabber.cpp
        :language: c
        :start-after: LITERAL_INCLUDE_START_2
        :end-before: LITERAL_INCLUDE_END_2

The newImage(...) slot is called when a new image arrives through the QMultimedia framework. The data is serialized according to :ref:`tutorial:Data Format` and transmitted over the output pin.

Plugin Definition
^^^^^^^^^^^^^^^^^

For being able to announce the C++ filters, the plugin needs to be defined. This is performed here for the CameraGrabber class and other filters defined in the same library.

    .. literalinclude:: ../../nexxT/tests/src/Plugins.cpp
        :language: c

